Ext.data.JsonP.Ext_layout_Context({"tagname":"class","name":"Ext.layout.Context","extends":"Ext.Base","mixins":[],"alternateClassNames":[],"aliases":{},"singleton":false,"requires":["Ext.util.Queue","Ext.layout.ContextItem","Ext.layout.Layout","Ext.fx.Anim","Ext.fx.Manager"],"uses":[],"code_type":"ext_define","inheritable":false,"inheritdoc":null,"meta":{"docauthor":["译者: Wesley002<wzl107821628@gmail.com>"],"protected":true},"id":"class-Ext.layout.Context","members":{"cfg":[],"property":[{"name":"$onExtended","tagname":"property","owner":"Ext.Base","meta":{"private":true},"id":"property-S-onExtended"},{"name":"layoutQueue","tagname":"property","owner":"Ext.layout.Context","meta":{},"id":"property-layoutQueue"},{"name":"self","tagname":"property","owner":"Ext.Base","meta":{"protected":true},"id":"property-self"},{"name":"state","tagname":"property","owner":"Ext.layout.Context","meta":{},"id":"property-state"}],"method":[{"name":"addConfig","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-addConfig"},{"name":"addInheritableStatics","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-addInheritableStatics"},{"name":"addMember","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-addMember"},{"name":"addXtype","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-addXtype"},{"name":"callOverridden","tagname":"method","owner":"Ext.Base","meta":{"protected":true,"deprecated":{"version":"4.1","text":"版本 使用 {@link #callParent} 代替."}},"id":"method-callOverridden"},{"name":"callParent","tagname":"method","owner":"Ext.Base","meta":{"protected":true},"id":"method-callParent"},{"name":"extend","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-extend"},{"name":"flush","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-flush"},{"name":"getCmp","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-getCmp"},{"name":"getConfig","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-getConfig"},{"name":"getEl","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-getEl"},{"name":"getInitialConfig","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-getInitialConfig"},{"name":"hasConfig","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-hasConfig"},{"name":"implement","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-implement"},{"name":"initConfig","tagname":"method","owner":"Ext.Base","meta":{"protected":true},"id":"method-initConfig"},{"name":"invalidate","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-invalidate"},{"name":"mixin","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-mixin"},{"name":"onConfigUpdate","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-onConfigUpdate"},{"name":"onExtended","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-onExtended"},{"name":"queueAnimation","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-queueAnimation"},{"name":"queueCompletion","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-queueCompletion"},{"name":"queueFinalize","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-queueFinalize"},{"name":"queueFlush","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-queueFlush"},{"name":"queueInvalidate","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-queueInvalidate"},{"name":"queueLayout","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-queueLayout"},{"name":"resetLayout","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-resetLayout"},{"name":"run","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-run"},{"name":"runCycle","tagname":"method","owner":"Ext.layout.Context","meta":{"protected":true},"id":"method-runCycle"},{"name":"runLayout","tagname":"method","owner":"Ext.layout.Context","meta":{"private":true},"id":"method-runLayout"},{"name":"setConfig","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-setConfig"},{"name":"setItemSize","tagname":"method","owner":"Ext.layout.Context","meta":{},"id":"method-setItemSize"},{"name":"statics","tagname":"method","owner":"Ext.Base","meta":{"protected":true},"id":"method-statics"},{"name":"triggerExtended","tagname":"method","owner":"Ext.Base","meta":{"private":true},"id":"method-triggerExtended"}],"event":[],"css_var":[],"css_mixin":[]},"statics":{"cfg":[],"property":[],"method":[{"name":"addMembers","tagname":"method","owner":"Ext.Base","meta":{"static":true},"id":"static-method-addMembers"},{"name":"addStatics","tagname":"method","owner":"Ext.Base","meta":{"static":true},"id":"static-method-addStatics"},{"name":"borrow","tagname":"method","owner":"Ext.Base","meta":{"static":true,"private":true},"id":"static-method-borrow"},{"name":"create","tagname":"method","owner":"Ext.Base","meta":{"static":true},"id":"static-method-create"},{"name":"createAlias","tagname":"method","owner":"Ext.Base","meta":{"static":true},"id":"static-method-createAlias"},{"name":"getName","tagname":"method","owner":"Ext.Base","meta":{"static":true},"id":"static-method-getName"},{"name":"override","tagname":"method","owner":"Ext.Base","meta":{"static":true,"markdown":true,"deprecated":{"version":"4.1.0","text":"使用 {@link Ext#define Ext.define} 代替"}},"id":"static-method-override"}],"event":[],"css_var":[],"css_mixin":[]},"files":[{"filename":"Context.js","href":"Context2.html#Ext-layout-Context"}],"html_meta":{"docauthor":null,"protected":null},"component":false,"superclasses":["Ext.Base"],"subclasses":[],"mixedInto":[],"parentMixins":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'><a href='#!/api/Ext.Base' rel='Ext.Base' class='docClass'>Ext.Base</a><div class='subclass '><strong>Ext.layout.Context</strong></div></div><h4>Requires</h4><div class='dependency'><a href='#!/api/Ext.fx.Anim' rel='Ext.fx.Anim' class='docClass'>Ext.fx.Anim</a></div><div class='dependency'><a href='#!/api/Ext.fx.Manager' rel='Ext.fx.Manager' class='docClass'>Ext.fx.Manager</a></div><div class='dependency'><a href='#!/api/Ext.layout.ContextItem' rel='Ext.layout.ContextItem' class='docClass'>Ext.layout.ContextItem</a></div><div class='dependency'><a href='#!/api/Ext.layout.Layout' rel='Ext.layout.Layout' class='docClass'>Ext.layout.Layout</a></div><div class='dependency'><a href='#!/api/Ext.util.Queue' rel='Ext.util.Queue' class='docClass'>Ext.util.Queue</a></div><h4>Files</h4><div class='dependency'><a href='source/Context2.html#Ext-layout-Context' target='_blank'>Context.js</a></div></pre><div class='doc-contents'><p>管理一次布局中的全局环境.</p>\n\n<h1>算法</h1>\n\n<p>本类负责执行以下工作:</p>\n\n<ul>\n<li>缓存DOM读操作以避免重复读取同一值.</li>\n<li>缓冲DOM写操作并将其存储为阻塞流, 以避免读写冲突.</li>\n<li>跟踪布局的依赖关联, 这样就不用每个布局都必须计算出其依赖值的来源.</li>\n<li>智能地判断当布局依赖值发生变化时, 重新布局.(触发属性)</li>\n<li>允许布局在缺失必要的属性值时暂不执行. (阻塞属性)</li>\n</ul>\n\n\n<p>当布局执行到\"读阶段\"或\"写阶段\"时, 必须始终明确当前处于哪个阶段. 多数\n<a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Layout</a>中的函数在读阶段被调用, 如\n<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">claculate</a>,\n<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a> 和\n<a href=\"#!/api/Ext.layout.Layout-method-finalizeLayout\" rel=\"Ext.layout.Layout-method-finalizeLayout\" class=\"docClass\">finalizeLayout</a>.\n但也有例外, 如<a href=\"#!/api/Ext.layout.Layout-method-beginLayout\" rel=\"Ext.layout.Layout-method-beginLayout\" class=\"docClass\">beginLayout</a>,\n<a href=\"#!/api/Ext.layout.Layout-method-beginLayoutCycle\" rel=\"Ext.layout.Layout-method-beginLayoutCycle\" class=\"docClass\">beginLayoutCycle</a> 和\n<a href=\"#!/api/Ext.layout.Layout-method-finishedLayout\" rel=\"Ext.layout.Layout-method-finishedLayout\" class=\"docClass\">finishedLayout</a> 则在写阶段被调用.\n当 <a href=\"#!/api/Ext.layout.Layout-method-finishedLayout\" rel=\"Ext.layout.Layout-method-finishedLayout\" class=\"docClass\">finishedLayout</a> 在写阶段被调用时,\n只能表示它将作为一次布局执行完成之后, 作全部捕捉并进行后续处理.</p>\n\n<p>在读阶段, 对DOM的读操作应该使用相应的<a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">ContextItem</a>来进行, 它会\n通过提供缓存来避免重复的读取. 在读阶段绝不应该发生写操作! 需要写入的值应该被存入相应的\n<a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">ContextItem</a> 等待稍后被写入.</p>\n\n<p>写阶段的规则与读阶段相似. 唯一的区别就是 <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">ContextItem</a> 的一些方法如\n<a href=\"#!/api/Ext.layout.ContextItem-method-getStyle\" rel=\"Ext.layout.ContextItem-method-getStyle\" class=\"docClass\">getStyle</a> 仍然会对之前没有读取过的DOM属性值进行读操作.\n这些细节对ContextItem的外部是不可见的, 所以在写阶段仍应该避免对ContextItem进行读操作.</p>\n\n<p>计算布局间的相互依赖需要一次确定次数的循环. 在一次循环中, 某些布局会出去处理其他布局的计算结果.\n计算流程为: 将组件树中的所有布局(组件和容器的)排成队列. 初始队列的顺序是自底向上的, 且组件布局\n优先, 然后是容器布局(如果存在).</p>\n\n<p>在初始阶段, 会调用所有布局的 <a href=\"#!/api/Ext.layout.Layout-method-beginLayout\" rel=\"Ext.layout.Layout-method-beginLayout\" class=\"docClass\">beginLayout</a> 方法来清除\n来自DOM的干扰值. 换句话说, 这就是一个\"写阶段\", 此时应该被严格避免对DOM的读操作.</p>\n\n<p>接下来布局进入迭代阶段, 或称之为\"多重周期\"阶段. 每个周期将会调用<a href=\"#!/api/Ext.layout.Context-property-layoutQueue\" rel=\"Ext.layout.Context-property-layoutQueue\" class=\"docClass\">layoutQueue</a>中所有布局的\n<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>方法. 这些调用属于\"写阶段\", 此时须完全避免对DOM\n的写操作.</p>\n\n<h1>注意事项</h1>\n\n<p><strong>规则 1</strong>: 重视读/写周期. 总是使用<a href=\"#!/api/Ext.layout.ContextItem-method-getProp\" rel=\"Ext.layout.ContextItem-method-getProp\" class=\"docClass\">getProp</a>\n或 <a href=\"#!/api/Ext.layout.ContextItem-method-getDomProp\" rel=\"Ext.layout.ContextItem-method-getDomProp\" class=\"docClass\">getDomProp</a> 方法来获取计算值;\n只使用 <a href=\"#!/api/Ext.layout.ContextItem-method-getStyle\" rel=\"Ext.layout.ContextItem-method-getStyle\" class=\"docClass\">getStyle</a> 方法来读取style; 使用\n<a href=\"#!/api/Ext.layout.ContextItem-method-setProp\" rel=\"Ext.layout.ContextItem-method-setProp\" class=\"docClass\">setProp</a> 方法来设入DOM属性值. 当然不可避免的\n有些读取操作仍然会直接来自DOM, 但如果 <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">ContextItem</a> 中\n有函数做了相应的工作, 就应该用它来做底层地等效替换.</p>\n\n<p><a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>的基本逻辑为: 使用\n<a href=\"#!/api/Ext.layout.ContextItem-method-getProp\" rel=\"Ext.layout.ContextItem-method-getProp\" class=\"docClass\">getProp</a> 或\n<a href=\"#!/api/Ext.layout.ContextItem-method-getDomProp\" rel=\"Ext.layout.ContextItem-method-getDomProp\" class=\"docClass\">getDomProp</a> 获取值, 计算结果并通过\n<a href=\"#!/api/Ext.layout.ContextItem-method-setProp\" rel=\"Ext.layout.ContextItem-method-setProp\" class=\"docClass\">setProp</a> 发布. 需要注意的是\n<a href=\"#!/api/Ext.layout.ContextItem-method-getProp\" rel=\"Ext.layout.ContextItem-method-getProp\" class=\"docClass\">getProp</a> 会在获取未知值时返回'undefined'. 但是调用该方法\n这个行为会似的布局依赖并追踪这个值(在某种程度上). 换句话说, 布局的调用将会通过属性来请求\"触发\".</p>\n\n<p><strong>规则 2</strong>: 除非属性值是必须的, 否则尽量避免调用<a href=\"#!/api/Ext.layout.ContextItem-method-getProp\" rel=\"Ext.layout.ContextItem-method-getProp\" class=\"docClass\">getProp</a>.\n多余的调用会降低效率因为布局将会依赖于从未真正使用过的值.  这条规则也同样适用于\n<a href=\"#!/api/Ext.layout.ContextItem-method-getDomProp\" rel=\"Ext.layout.ContextItem-method-getDomProp\" class=\"docClass\">getDomProp</a> 以及判断函数\n<a href=\"#!/api/Ext.layout.ContextItem-method-hasProp\" rel=\"Ext.layout.ContextItem-method-hasProp\" class=\"docClass\">hasProp</a> 和 <a href=\"#!/api/Ext.layout.ContextItem-method-hasDomProp\" rel=\"Ext.layout.ContextItem-method-hasDomProp\" class=\"docClass\">hasDomProp</a>.</p>\n\n<p>因为 <a href=\"#!/api/Ext.layout.ContextItem-method-getProp\" rel=\"Ext.layout.ContextItem-method-getProp\" class=\"docClass\">getProp</a> 可能返回'undefined', 这通常会导致后续的数学\n计算得到NaN. 仅仅是单独传递NaN或最终结果为NaN, 这通常都没有问题. 'undefined'和NaN都会被\n<a href=\"#!/api/Ext.layout.ContextItem-method-setProp\" rel=\"Ext.layout.ContextItem-method-setProp\" class=\"docClass\">Ext.layout.ContextItem.setProp</a> 忽略, 因此多数时候没有必要去注意这种情况. 只有在它导致布局\n不被执行或发布一个错误的计算值(非'undefined'或NaN)时, 才变得值得关注.</p>\n\n<p><strong>规则 3</strong>: 如果一个布局并没有计算出它需要计算的全部的值, 则<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>\n在返回前必须将 <a href=\"#!/api/Ext.layout.Layout-property-done\" rel=\"Ext.layout.Layout-property-done\" class=\"docClass\">done</a> 设为 'false'. 该值初始化时为'true'因为得到\n未完成状态比完成状态更容易一些(特别是上层和下层的类层次结构中).</p>\n\n<p><strong>规则 4</strong>: 一次布局绝不能返回一次未完成(错误)的结果. 否则将导致其他依赖布局使用错误的值进行计算, 从而\n导致更多的错误值, 甚至一些布局在正确的结果尚未返回前就已经错误的标记自己的\n<a href=\"#!/api/Ext.layout.Layout-property-done\" rel=\"Ext.layout.Layout-property-done\" class=\"docClass\">done</a>为完成状态. 这将破坏整个计算过程.</p>\n\n<p><strong>规则 5</strong>: 每一个值只应该由一个布局发布. 如果多个布局试图发布同一个值, 这将几乎无法避免的破坏<strong>规则 4</strong>.\n为了帮助检测到这个问题, 布局诊断工具会对这种试图从不同的布局来得到一个值的行为设置陷阱.</p>\n\n<p>复合布局的计算会由产生很多个结果. 这些结果值对于其他布局的计算十分重要, 需要尽可能早的通过\n<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">Ext.layout.Layout.calculate</a> 来发布以避免不必要循环周期和性能消耗. 可是对于某些结果, 他们因为一些\n方式被关联在了一起, 从而使得他们的发布将会是全有或全空的.(典型的遵循<strong>规则 4</strong>的行为).</p>\n\n<p><strong>规则 6</strong>: 一旦确认某些结果是正确的, 就应该立刻将他们发布, 不要等到全部的结果都计算完成才发布. 等待\n全部计算都完成将会导致死锁. 这里的关键是在处理过程中遵循<strong>规则 4</strong>.</p>\n\n<p>有些布局的计算依赖于某些关键值. 例如, HBox依赖width, 在width值未知时什么也做不了. 对于这种情况, 最好的办法\n就是通过使用 <a href=\"#!/api/Ext.layout.ContextItem-method-block\" rel=\"Ext.layout.ContextItem-method-block\" class=\"docClass\">block</a> 或 <a href=\"#!/api/Ext.layout.ContextItem-method-domBlock\" rel=\"Ext.layout.ContextItem-method-domBlock\" class=\"docClass\">domBlock</a>\n(阻塞属性), 从而使布局等到这些值可用使才继续处理.</p>\n\n<p><strong>规则 7</strong>: 当值需要进一步处理才能得到时, 使用<a href=\"#!/api/Ext.layout.ContextItem-method-block\" rel=\"Ext.layout.ContextItem-method-block\" class=\"docClass\">block</a> 或\n<a href=\"#!/api/Ext.layout.ContextItem-method-domBlock\" rel=\"Ext.layout.ContextItem-method-domBlock\" class=\"docClass\">domBlock</a>(阻塞属性). 这样能够尽可能减少浪费地重复计算.</p>\n\n<p><strong>规则 8</strong>: 阻塞只能在当前处理无法继续的情况下才能使用. 如果还尚有任何一个值可以被计算, 阻塞都可能导致死锁.</p>\n\n<p>在之前的版本中, 布局由组件的代码直接调用, 有时在子组件如'afterLayout'函数中调用. 随着现在版本的灵活性,\n为了解决布局时的复杂性和迭代问题, 这些工作应该由一个专门负责的布局(作为组件或容器)来完成.</p>\n\n<p><strong>规则 9</strong>: 用布局集合来解决布局问题, 而不是等待一个布局完成后再去引发执行其他的布局. 这对于现在的布局处理\n非常重要, 因为现在处理的整个组件树, 而非孤立的某个布局.</p>\n\n<h1>时序图</h1>\n\n<p>一个最简单的布局执行的时序图大致如下:</p>\n\n<pre><code>  Context         Layout 1     Item 1     Layout 2     Item 2\n     |               |           |           |           |\n----&gt;X--------------&gt;X           |           |           |\nrun  X---------------|-----------|----------&gt;X           |\n     X beginLayout   |           |           |           |\n     X               |           |           |           |\n   A X--------------&gt;X           |           |           |\n     X  calculate    X----------&gt;X           |           |\n     X             C X  getProp  |           |           |\n   B X               X----------&gt;X           |           |\n     X               |  setProp  |           |           |\n     X               |           |           |           |\n   D X---------------|-----------|----------&gt;X           |\n     X  calculate    |           |           X----------&gt;X\n     X               |           |           |  setProp  |\n   E X               |           |           |           |\n     X---------------|-----------|----------&gt;X           |\n     X completeLayout|           |         F |           |\n     X               |           |           |           |\n   G X               |           |           |           |\n   H X--------------&gt;X           |           |           |\n     X  calculate    X----------&gt;X           |           |\n     X             I X  getProp  |           |           |\n     X               X----------&gt;X           |           |\n     X               |  setProp  |           |           |\n   J X--------------&gt;X           |           |           |\n     X completeLayout|           |           |           |\n     X               |           |           |           |\n   K X--------------&gt;X           |           |           |\n     X---------------|-----------|----------&gt;X           |\n     X finalizeLayout|           |           |           |\n     X               |           |           |           |\n   L X--------------&gt;X           |           |           |\n     X---------------|-----------|----------&gt;X           |\n     X finishedLayout|           |           |           |\n     X               |           |           |           |\n   M X--------------&gt;X           |           |           |\n     X---------------|-----------|----------&gt;X           |\n     X notifyOwner   |           |           |           |\n   N |               |           |           |           |\n     -               -           -           -           -\n</code></pre>\n\n<p>说明:</p>\n\n<p><strong>A.</strong> 这是一次从函数<a href=\"#!/api/Ext.layout.Context-method-run\" rel=\"Ext.layout.Context-method-run\" class=\"docClass\">run</a>到函数<a href=\"#!/api/Ext.layout.Context-method-runCycle\" rel=\"Ext.layout.Context-method-runCycle\" class=\"docClass\">runCycle</a>的调用.\n队列中的每个布局<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>函数的都将被调用.</p>\n\n<p><strong>B.</strong> 每当<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>函数调用后, 都会检查\n<a href=\"#!/api/Ext.layout.Layout-property-done\" rel=\"Ext.layout.Layout-property-done\" class=\"docClass\">done</a> 标记看布局是否完成. 如果完成且此布局对象含有\n<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a>函数, 则布局加入队列等待此函数的调用.\n若未完成, 布局会重新加入计算队列, 除非有阻塞属性(blocks)或触发属性(triggers)来控制他的队列位置.</p>\n\n<p><strong>C.</strong> 对Item属性调用<a href=\"#!/api/Ext.layout.ContextItem-method-getProp\" rel=\"Ext.layout.ContextItem-method-getProp\" class=\"docClass\">getProp</a>, 会将它作为触发属性进行监听\n(以请求的属性名称作为键值). 对属性的修改会导致布局被重新加入计算队列.\n调用 <a href=\"#!/api/Ext.layout.ContextItem-method-setProp\" rel=\"Ext.layout.ContextItem-method-setProp\" class=\"docClass\">setProp</a> 则会将值设入Item属性而不是直接设入DOM.</p>\n\n<p><strong>D.</strong> 以同样的循环, 调用其他布局(对每个布局重复步骤<strong>B</strong>和<strong>C</strong>.), 进入第一个周期.</p>\n\n<p><strong>E.</strong> 当一个周期结束, 如果有处理被执行(新的属性被写入上下文)且<a href=\"#!/api/Ext.layout.Context-property-layoutQueue\" rel=\"Ext.layout.Context-property-layoutQueue\" class=\"docClass\">layoutQueue</a>队列非空, 则进入下一个周期.\n如果无处理被执行或队列中已没有待运行的布局, 则将所有缓存值写入DOM(一次刷新).</p>\n\n<p><strong>F.</strong> 刷新后, 所有<a href=\"#!/api/Ext.layout.Layout-property-done\" rel=\"Ext.layout.Layout-property-done\" class=\"docClass\">done</a>标记完成状态的布局, 调用其\n<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a>函数(如果有). 这会是他们再次被标记\n为未完成(参见<a href=\"#!/api/Ext.layout.Context-method-invalidate\" rel=\"Ext.layout.Context-method-invalidate\" class=\"docClass\">invalidate</a>), 由于<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>也将被调用,\n此时应认为处于\"读阶段\", 应该避免所有对DOM的写操作.</p>\n\n<p><strong>G.</strong> 刷新和调用任何进行中的<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a>函数\n通常会由调用<a href=\"#!/api/Ext.layout.ContextItem-method-getDomProp\" rel=\"Ext.layout.ContextItem-method-getDomProp\" class=\"docClass\">getDomProp</a> 使得触发属性产生新的布局计算,\n以及由调用<a href=\"#!/api/Ext.layout.ContextItem-method-domBlock\" rel=\"Ext.layout.ContextItem-method-domBlock\" class=\"docClass\">domBlock</a> 访问阻塞属性从而解除阻塞中布局.\n这些属性变量出现在布局需要得到DOM中的准确值却无法直接获取时. 如果此过程中未使得任何布局加入队列,\n则认为布局<em>失败</em>. 否则, 我们继续下一循环周期.</p>\n\n<p><strong>H.</strong> 在循环周期的开始调用队列中所有布局的<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>函数.\n重复步骤<strong>B</strong>到<strong>G</strong>.</p>\n\n<p><strong>I.</strong> 一旦布局完成了全部自己负责的计算, 就可以将自己的<a href=\"#!/api/Ext.layout.Layout-property-done\" rel=\"Ext.layout.Layout-property-done\" class=\"docClass\">done</a>置为完成状态.\n此状态值等于刚进入<a href=\"#!/api/Ext.layout.Layout-method-calculate\" rel=\"Ext.layout.Layout-method-calculate\" class=\"docClass\">calculate</a>时的值, 且如果还有任何未完成的工作,\n都应清除此状态值.</p>\n\n<p><strong>J.</strong> 现在所有的布局都已完成, 刷新所有的DOM值并调用<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a>.\n这将再次导致布局进入未完成状态, 然后我们也将再次回到另一个可能发生循环周期中.</p>\n\n<p><strong>K.</strong> 在所有的布局全部完成后, 调用所有布局的<a href=\"#!/api/Ext.layout.Layout-method-finalizeLayout\" rel=\"Ext.layout.Layout-method-finalizeLayout\" class=\"docClass\">finalizeLayout</a>函数.\n由于<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a> 的调用将导致布局再次变成未完成状态.\n这比使用<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">completeLayout</a> 来说还是不太理想因为这将导致所有的\n<a href=\"#!/api/Ext.layout.Layout-method-finalizeLayout\" rel=\"Ext.layout.Layout-method-finalizeLayout\" class=\"docClass\">finalizeLayout</a> 函数都被再次调用, 即使是在我们认为事情都已结束的情况下.</p>\n\n<p><strong>L.</strong> 在完成最后一次迭代之后, 所有布局的<a href=\"#!/api/Ext.layout.Layout-method-finishedLayout\" rel=\"Ext.layout.Layout-method-finishedLayout\" class=\"docClass\">finishedLayout</a>函数(如果有)将\n被调用. 此调用针对每次<a href=\"#!/api/Ext.layout.Context-method-run\" rel=\"Ext.layout.Context-method-run\" class=\"docClass\">run</a>仅会发生一次, 且不会再导致进一步的布局.</p>\n\n<p><strong>M.</strong> 在<a href=\"#!/api/Ext.layout.Layout-method-finishedLayout\" rel=\"Ext.layout.Layout-method-finishedLayout\" class=\"docClass\">finishedLayout</a> 完成调用之后,\n所有布局的<a href=\"#!/api/Ext.layout.Layout-method-notifyOwner\" rel=\"Ext.layout.Layout-method-notifyOwner\" class=\"docClass\">notifyOwner</a>函数(如果有)将\n被调用. 此调用针对每次<a href=\"#!/api/Ext.layout.Context-method-run\" rel=\"Ext.layout.Context-method-run\" class=\"docClass\">run</a>仅会发生一次, 且不会再导致进一步的布局.</p>\n\n<p><strong>N.</strong> 一次最后的刷新以保证所有数据都被写入DOM.</p>\n\n<h1>布局内部协作</h1>\n\n<p>很多布局问题需要多个布局间的协作. 某些情况下, 这可以被简单的理解为一个组件所属的容器的布局的计算结果提供\n给组件的布局使用, 反之亦然. 一种稍远一些的协作出现在设置了最大伸展属性和盒布局中: 子组件的布局的计算结果\n提供给父组件的布局, 再由父组件的布局来决定子组件的大小.</p>\n\n<p>容器和其子组件直接各式各样的依赖关系, 由每个组件的<a href=\"#!/api/Ext.AbstractComponent-method-getSizeModel\" rel=\"Ext.AbstractComponent-method-getSizeModel\" class=\"docClass\">尺寸模型(getSizeModel)</a>\n来描述.</p>\n\n<p>为了保证协作的完成, 下面几对属性将被赋入组件的 <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">ContextItem</a>中:</p>\n\n<ul>\n<li>width/height: 他们存储着组件的最终大小. 由被<a href=\"#!/api/Ext.AbstractComponent-method-getSizeModel\" rel=\"Ext.AbstractComponent-method-getSizeModel\" class=\"docClass\">尺寸模型(getSizeModel)</a>\n指明的布局负责赋值.</li>\n<li>contentWidth/contentHeight: 他们存储着由容器布局或容器DOM提供的大小数据. 他们仅描述容器内容的大小.\n他们用于在组件(<a href=\"#!/api/Ext.AbstractComponent-cfg-shrinkWrap\" rel=\"Ext.AbstractComponent-cfg-shrinkWrap\" class=\"docClass\">受到容器约束(shrinkWrap)</a>)时,计算组件的外围大小.\n他们也被用于溢出判断. 所有容器布局必须发布这些值来标识他们的约束大小. 如果一个组件包含未处理的内容(非容器的子组件),\n则组件的布局也必须发布这些值.</li>\n</ul>\n\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-property'>Properties</h3><div class='subsection'><div id='property-S-onExtended' class='member first-child inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-property-S-onExtended' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-property-S-onExtended' class='name expandable'>$onExtended</a><span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a></span><strong class='private signature'>private</strong></div><div class='description'><div class='short'>扩展事件 ...</div><div class='long'><p>扩展事件</p>\n<p>Defaults to: <code>[]</code></p></div></div></div><div id='property-layoutQueue' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-property-layoutQueue' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-property-layoutQueue' class='name not-expandable'>layoutQueue</a><span> : <a href=\"#!/api/Ext.util.Queue\" rel=\"Ext.util.Queue\" class=\"docClass\">Ext.util.Queue</a></span></div><div class='description'><div class='short'><p>待执行的布局队列.</p>\n</div><div class='long'><p>待执行的布局队列.</p>\n</div></div></div><div id='property-self' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-property-self' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-property-self' class='name expandable'>self</a><span> : <a href=\"#!/api/Ext.Class\" rel=\"Ext.Class\" class=\"docClass\">Ext.Class</a></span><strong class='protected signature'>protected</strong></div><div class='description'><div class='short'>本身\n\n获取当前类的引用，此对象被实例化。不同于 statics,\nthis.self是依赖范围，它意味着要使用动态继承。 ...</div><div class='long'><p>本身</p>\n\n<p>获取当前类的引用，此对象被实例化。不同于 <a href=\"#!/api/Ext.Base-method-statics\" rel=\"Ext.Base-method-statics\" class=\"docClass\">statics</a>,\n<code>this.self</code>是依赖范围，它意味着要使用动态继承。\n参见 <a href=\"#!/api/Ext.Base-method-statics\" rel=\"Ext.Base-method-statics\" class=\"docClass\">statics</a> 详细对比</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Cat', {\n    statics: {\n        speciesName: 'Cat' // My.Cat.speciesName = 'Cat'\n    },\n\n    constructor: function() {\n        alert(this.self.speciesName); // 依赖 'this'\n    },\n\n    clone: function() {\n        return new this.self();\n    }\n});\n\n\n<a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.SnowLeopard', {\n    extend: 'My.Cat',\n    statics: {\n        speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'\n    }\n});\n\nvar cat = new My.Cat();                     // alerts 'Cat' 猫\nvar snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard' 雪豹\n\nvar clone = snowLeopard.clone();\nalert(<a href=\"#!/api/Ext-method-getClassName\" rel=\"Ext-method-getClassName\" class=\"docClass\">Ext.getClassName</a>(clone));             // alerts 'My.SnowLeopard'\n</code></pre>\n</div></div></div><div id='property-state' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-property-state' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-property-state' class='name expandable'>state</a><span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a></span></div><div class='description'><div class='short'>以下值之一:\n\n\n0 - 运行前\n1 - 运行中\n2 - 运行完成 ...</div><div class='long'><p>以下值之一:</p>\n\n<ul>\n<li>0 - 运行前</li>\n<li>1 - 运行中</li>\n<li>2 - 运行完成</li>\n</ul>\n\n<p>Defaults to: <code>0</code></p></div></div></div></div></div><div class='members-section'><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Instance Methods</h3><div id='method-addConfig' class='member first-child inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-addConfig' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-addConfig' class='name expandable'>addConfig</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> config</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>添加配置 ...</div><div class='long'><p>添加配置</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>配置</p>\n</div></li></ul></div></div></div><div id='method-addInheritableStatics' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-addInheritableStatics' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-addInheritableStatics' class='name expandable'>addInheritableStatics</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> members</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>members</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>成员</p>\n</div></li></ul></div></div></div><div id='method-addMember' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-addMember' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-addMember' class='name expandable'>addMember</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> name, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> member</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'> ...</div><div class='long'>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>name</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>名称</p>\n</div></li><li><span class='pre'>member</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>成员</p>\n</div></li></ul></div></div></div><div id='method-addXtype' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-addXtype' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-addXtype' class='name expandable'>addXtype</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> xtype</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>添加 Xtype ...</div><div class='long'><p>添加 Xtype</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>xtype</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-callOverridden' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-callOverridden' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-callOverridden' class='name expandable'>callOverridden</a>( <span class='pre'><a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a>/Arguments </span> ) : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><strong class='deprecated signature'>deprecated</strong><strong class='protected signature'>protected</strong></div><div class='description'><div class='short'>调用原来的方法，这是以前的override重写\n\nExt.define('My.Cat', {\n    constructor: function() {\n        alert(\"I'm a cat!\");\n    }\n});\n...</div><div class='long'><p>调用原来的方法，这是以前的<a href=\"#!/api/Ext.Base-static-method-override\" rel=\"Ext.Base-static-method-override\" class=\"docClass\">override</a>重写</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Cat', {\n    constructor: function() {\n        alert(\"I'm a cat!\");\n    }\n});\n\nMy.Cat.override({\n    constructor: function() {\n        alert(\"I'm going to be a cat!\");\n\n        this.callOverridden();\n\n        alert(\"Meeeeoooowwww\");\n    }\n});\n\nvar kitty = new My.Cat(); // alerts \"I'm going to be a cat!\"\n                          // alerts \"I'm a cat!\"\n                          // alerts \"Meeeeoooowwww\"\n</code></pre>\n        <div class='signature-box deprecated'>\n        <p>This method has been <strong>deprecated</strong> since 4.1</p>\n        <p>版本 使用 <a href=\"#!/api/Ext.Base-method-callParent\" rel=\"Ext.Base-method-callParent\" class=\"docClass\">callParent</a> 代替.</p>\n\n        </div>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'></span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a>/Arguments<div class='sub-desc'><p>参数的参数，数组或'参数'对象\n来自当前方法，例如： <code>this.callOverridden(arguments)</code></p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a></span><div class='sub-desc'><p>返回调用重写方法的结果。</p>\n</div></li></ul></div></div></div><div id='method-callParent' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-callParent' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-callParent' class='name expandable'>callParent</a>( <span class='pre'><a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a>/Arguments args</span> ) : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><strong class='protected signature'>protected</strong></div><div class='description'><div class='short'>所谓的\"parent\"方法是指当前的方法。 ...</div><div class='long'><p>所谓的\"parent\"方法是指当前的方法。\n这是以前的方法派生或重写(参见 <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>)。</p>\n\n<pre><code> <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Base', {\n     constructor: function (x) {\n         this.x = x;\n     },\n\n     statics: {\n         method: function (x) {\n             return x;\n         }\n     }\n });\n\n <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Derived', {\n     extend: 'My.Base',\n\n     constructor: function () {\n         this.callParent([21]);\n     }\n });\n\n var obj = new My.Derived();\n\n alert(obj.x);  // alerts 21\n</code></pre>\n\n<p>这可以用来重写如下:</p>\n\n<pre><code> <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.DerivedOverride', {\n     override: 'My.Derived',\n\n     constructor: function (x) {\n         this.callParent([x*2]); // 调用原来的My.Derived构造\n     }\n });\n\n var obj = new My.Derived();\n\n alert(obj.x);  // 现在提示 42\n</code></pre>\n\n<p>This also works with static methods.</p>\n\n<pre><code> <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Derived2', {\n     extend: 'My.Base',\n\n     statics: {\n         method: function (x) {\n             return this.callParent([x*2]); // 调用 My.Base.method\n         }\n     }\n });\n\n alert(My.Base.method(10);     // alerts 10\n alert(My.Derived2.method(10); // alerts 20\n</code></pre>\n\n<p>然后，它也可以重写静态方法。</p>\n\n<pre><code> <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Derived2Override', {\n     override: 'My.Derived2',\n\n     statics: {\n         method: function (x) {\n             return this.callParent([x*2]); // 调用 My.Derived2.method\n         }\n     }\n });\n\n alert(My.Derived2.method(10); // 现在提示 40\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>args</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a>/Arguments<div class='sub-desc'><p>这个参数, 通过当前方法得到数组或者 <code>arguments</code> 对象,\n例如: <code>this.callParent(arguments)</code></p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a></span><div class='sub-desc'><p>返回调用父类的方法的结果。</p>\n</div></li></ul></div></div></div><div id='method-extend' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-extend' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-extend' class='name expandable'>extend</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> config</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>拓展 ...</div><div class='long'><p>拓展</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>配置</p>\n</div></li></ul></div></div></div><div id='method-flush' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-flush' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-flush' class='name expandable'>flush</a>( <span class='pre'></span> )</div><div class='description'><div class='short'>通过遍历刷新队列(flushQueue)中的ContextItem, 来刷新所有未写入DOM的属性值. ...</div><div class='long'><p>通过遍历刷新队列(flushQueue)中的ContextItem, 来刷新所有未写入DOM的属性值.</p>\n</div></div></div><div id='method-getCmp' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-getCmp' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-getCmp' class='name expandable'>getCmp</a>( <span class='pre'><a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a> cmp</span> )</div><div class='description'><div class='short'>返回组件的ContextItem ...</div><div class='long'><p>返回组件的ContextItem</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>cmp</span> : <a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-getConfig' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-getConfig' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-getConfig' class='name expandable'>getConfig</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> name</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>得到配置项 ...</div><div class='long'><p>得到配置项</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>name</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>名称</p>\n</div></li></ul></div></div></div><div id='method-getEl' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-getEl' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-getEl' class='name expandable'>getEl</a>( <span class='pre'><a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a> parent, <a href=\"#!/api/Ext.dom.Element\" rel=\"Ext.dom.Element\" class=\"docClass\">Ext.dom.Element</a> el</span> )</div><div class='description'><div class='short'>返回元素的ContextItem ...</div><div class='long'><p>返回元素的ContextItem</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>parent</span> : <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a><div class='sub-desc'>\n</div></li><li><span class='pre'>el</span> : <a href=\"#!/api/Ext.dom.Element\" rel=\"Ext.dom.Element\" class=\"docClass\">Ext.dom.Element</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-getInitialConfig' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-getInitialConfig' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-getInitialConfig' class='name expandable'>getInitialConfig</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> name</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>得到初始化配置项 ...</div><div class='long'><p>得到初始化配置项</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>name</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>名称</p>\n</div></li></ul></div></div></div><div id='method-hasConfig' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-hasConfig' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-hasConfig' class='name expandable'>hasConfig</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> config</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>根据名称判断配置项是否存在 ...</div><div class='long'><p>根据名称判断配置项是否存在</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>配置项</p>\n</div></li></ul></div></div></div><div id='method-implement' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-implement' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-implement' class='name expandable'>implement</a>( <span class='pre'></span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'> ...</div><div class='long'>\n</div></div></div><div id='method-initConfig' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-initConfig' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-initConfig' class='name expandable'>initConfig</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> config</span> ) : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><strong class='protected signature'>protected</strong></div><div class='description'><div class='short'>这个类的初始化配置。典型例子:\n\nExt.define('My.awesome.Class', {\n    // 这是默认配置\n    config: {\n        name: 'Awesome',\n        isAwes...</div><div class='long'><p>这个类的初始化配置。典型例子:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.awesome.Class', {\n    // 这是默认配置\n    config: {\n        name: 'Awesome',\n        isAwesome: true\n    },\n\n    constructor: function(config) {\n        this.initConfig(config);\n    }\n});\n\nvar awesome = new My.awesome.Class({\n    name: 'Super Awesome'\n});\n\nalert(awesome.getName()); // 'Super Awesome' 超级棒\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>配置</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a></span><div class='sub-desc'><p>mixins 混入原型 键-值对</p>\n</div></li></ul></div></div></div><div id='method-invalidate' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-invalidate' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-invalidate' class='name expandable'>invalidate</a>( <span class='pre'><a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>/<a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a> components, <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a> ownerCtContext, <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a> full</span> )</div><div class='description'><div class='short'>清除一个或多个组件的布局(组件和容器)的属性值. ...</div><div class='long'><p>清除一个或多个组件的布局(组件和容器)的属性值. 此函数可以在布局运行前被调用, 来识别需要进行布局的组件;\n也可以在布局运行中用来重启某组件的布局.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>components</span> : <a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>/<a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a><div class='sub-desc'><p>一个Components或Component数组.</p>\n</div></li><li><span class='pre'>ownerCtContext</span> : <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a><div class='sub-desc'><p>组件父容器的ContextItem.</p>\n</div></li><li><span class='pre'>full</span> : <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a><div class='sub-desc'><p>'ture' 为所有属性值都需要清除, 否则只有那些由组件计算的属性值被清除.</p>\n</div></li></ul></div></div></div><div id='method-mixin' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-mixin' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-mixin' class='name expandable'>mixin</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> name, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> mixinClass</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>内部使用混入预处理器（mixins pre-processor） ...</div><div class='long'><p>内部使用混入预处理器（mixins pre-processor）</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>name</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li><li><span class='pre'>mixinClass</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-onConfigUpdate' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-onConfigUpdate' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-onConfigUpdate' class='name expandable'>onConfigUpdate</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> names, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> callback, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>更新配置项 ...</div><div class='long'><p>更新配置项</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>names</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>名称</p>\n</div></li><li><span class='pre'>callback</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>回调</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>范围</p>\n</div></li></ul></div></div></div><div id='method-onExtended' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-onExtended' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-onExtended' class='name expandable'>onExtended</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> fn, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>扩展事件 ...</div><div class='long'><p>扩展事件</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-queueAnimation' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-queueAnimation' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-queueAnimation' class='name expandable'>queueAnimation</a>( <span class='pre'><a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a> item</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>将一个ContextItem加入Ext.layout.ContextItem.flushAnimations函数的执行队列 ...</div><div class='long'><p>将一个ContextItem加入Ext.layout.ContextItem.flushAnimations函数的执行队列</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>item</span> : <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-queueCompletion' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-queueCompletion' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-queueCompletion' class='name expandable'>queueCompletion</a>( <span class='pre'><a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Ext.layout.Layout</a> layout</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>将一个布局加入Ext.layout.Layout.completeLayout函数的执行队列. ...</div><div class='long'><p>将一个布局加入<a href=\"#!/api/Ext.layout.Layout-method-completeLayout\" rel=\"Ext.layout.Layout-method-completeLayout\" class=\"docClass\">Ext.layout.Layout.completeLayout</a>函数的执行队列.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>layout</span> : <a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Ext.layout.Layout</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-queueFinalize' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-queueFinalize' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-queueFinalize' class='name expandable'>queueFinalize</a>( <span class='pre'><a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Ext.layout.Layout</a> layout</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>将一个布局加入Ext.layout.Layout.finalizeLayout函数的执行队列. ...</div><div class='long'><p>将一个布局加入<a href=\"#!/api/Ext.layout.Layout-method-finalizeLayout\" rel=\"Ext.layout.Layout-method-finalizeLayout\" class=\"docClass\">Ext.layout.Layout.finalizeLayout</a>函数的执行队列.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>layout</span> : <a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Ext.layout.Layout</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-queueFlush' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-queueFlush' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-queueFlush' class='name expandable'>queueFlush</a>( <span class='pre'><a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a> item</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>将一个ContextItem加入下次刷新DOM的执行队列, 此函数只应由Ext.layout.ContextItem调用. ...</div><div class='long'><p>将一个ContextItem加入下次刷新DOM的执行队列, 此函数只应由<a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a>调用.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>item</span> : <a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-queueInvalidate' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-queueInvalidate' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-queueInvalidate' class='name expandable'>queueInvalidate</a>( <span class='pre'><a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>/<a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a> item, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> options</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>将一个组件(及其子组件树)加入下一周期属性值清除的队列 ...</div><div class='long'><p>将一个组件(及其子组件树)加入下一周期属性值清除的队列</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>item</span> : <a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>/<a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a><div class='sub-desc'><p>执行属性值清除的组件或ContextItem.</p>\n</div></li><li><span class='pre'>options</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>一个对象,用于描述如何执行属性值清除 (详情参见<a href=\"#!/api/Ext.layout.ContextItem-method-invalidate\" rel=\"Ext.layout.ContextItem-method-invalidate\" class=\"docClass\">Ext.layout.ContextItem.invalidate</a>).</p>\n</div></li></ul></div></div></div><div id='method-queueLayout' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-queueLayout' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-queueLayout' class='name expandable'>queueLayout</a>( <span class='pre'><a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Ext.layout.Layout</a> layout</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>将一个布局加入下次计算循环周期的队列. ...</div><div class='long'><p>将一个布局加入下次计算循环周期的队列. 当布局为完成, 阻塞状态或已在队列中时不应调用此函数.此函数只能由\n本类和<a href=\"#!/api/Ext.layout.ContextItem\" rel=\"Ext.layout.ContextItem\" class=\"docClass\">Ext.layout.ContextItem</a>调用.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>layout</span> : <a href=\"#!/api/Ext.layout.Layout\" rel=\"Ext.layout.Layout\" class=\"docClass\">Ext.layout.Layout</a><div class='sub-desc'><p>加入队列的布局.</p>\n</div></li></ul></div></div></div><div id='method-resetLayout' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-resetLayout' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-resetLayout' class='name expandable'>resetLayout</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> layout, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> ownerContext, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> firstTime</span> )</div><div class='description'><div class='short'>重置布局对象. ...</div><div class='long'><p>重置布局对象. 此函数在运行开始或运行中时由 <a href=\"#!/api/Ext.layout.Context-method-invalidate\" rel=\"Ext.layout.Context-method-invalidate\" class=\"docClass\">invalidate</a> 调用.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>layout</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li><li><span class='pre'>ownerContext</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li><li><span class='pre'>firstTime</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-run' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-run' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-run' class='name expandable'>run</a>( <span class='pre'></span> ) : <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a></div><div class='description'><div class='short'>运行布局计算. ...</div><div class='long'><p>运行布局计算. 此函数在本对象中只能被执行一次.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a></span><div class='sub-desc'><p>'true' 表示所有布局都执行完毕, 'false' 表示没有.</p>\n</div></li></ul></div></div></div><div id='method-runCycle' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-runCycle' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-runCycle' class='name expandable'>runCycle</a>( <span class='pre'></span> ) : <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a><strong class='protected signature'>protected</strong></div><div class='description'><div class='short'>遍历调用待执行队列中的布局. ...</div><div class='long'><p>遍历调用待执行队列中的布局.</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a></span><div class='sub-desc'><p>'true' 表示有布局被运行, 'false' 表示没有.</p>\n</div></li></ul></div></div></div><div id='method-runLayout' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-runLayout' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-runLayout' class='name expandable'>runLayout</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> layout</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>Runs one layout as part of a cycle. ...</div><div class='long'><p>Runs one layout as part of a cycle.\n运行一个循环周期中的一个布局.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>layout</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-setConfig' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-setConfig' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-setConfig' class='name expandable'>setConfig</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> config, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> applyIfNotSet</span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>设置配置项 ...</div><div class='long'><p>设置配置项</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li><li><span class='pre'>applyIfNotSet</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-setItemSize' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.layout.Context'>Ext.layout.Context</span><br/><a href='source/Context2.html#Ext-layout-Context-method-setItemSize' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.layout.Context-method-setItemSize' class='name expandable'>setItemSize</a>( <span class='pre'><a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>/<a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>[]/<a href=\"#!/api/Ext.dom.Element\" rel=\"Ext.dom.Element\" class=\"docClass\">Ext.dom.Element</a>/<a href=\"#!/api/Ext.dom.Element\" rel=\"Ext.dom.Element\" class=\"docClass\">Ext.dom.Element</a>[]/<a href=\"#!/api/Ext.dom.CompositeElement\" rel=\"Ext.dom.CompositeElement\" class=\"docClass\">Ext.dom.CompositeElement</a> item, <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> width, <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> height</span> )</div><div class='description'><div class='short'>Set the size of a component, element or composite or an array of components or elements. ...</div><div class='long'><p>Set the size of a component, element or composite or an array of components or elements.\n为一个组件, 元素, 组合结构或组件,元素的数组的尺寸大小赋值</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>item</span> : <a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>/<a href=\"#!/api/Ext.Component\" rel=\"Ext.Component\" class=\"docClass\">Ext.Component</a>[]/<a href=\"#!/api/Ext.dom.Element\" rel=\"Ext.dom.Element\" class=\"docClass\">Ext.dom.Element</a>/<a href=\"#!/api/Ext.dom.Element\" rel=\"Ext.dom.Element\" class=\"docClass\">Ext.dom.Element</a>[]/<a href=\"#!/api/Ext.dom.CompositeElement\" rel=\"Ext.dom.CompositeElement\" class=\"docClass\">Ext.dom.CompositeElement</a><div class='sub-desc'><p>赋值对象.</p>\n</div></li><li><span class='pre'>width</span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>新的宽度值 (undefined 和 NaN将被忽略).</p>\n</div></li><li><span class='pre'>height</span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>新的高度值 (undefined 和 NaN将被忽略).</p>\n</div></li></ul></div></div></div><div id='method-statics' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-statics' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-statics' class='name expandable'>statics</a>( <span class='pre'></span> ) : <a href=\"#!/api/Ext.Class\" rel=\"Ext.Class\" class=\"docClass\">Ext.Class</a><strong class='protected signature'>protected</strong></div><div class='description'><div class='short'>获取从该对象被实例化的类的引用。 ...</div><div class='long'><p>获取从该对象被实例化的类的引用。 请注意不同于 <a href=\"#!/api/Ext.Base-property-self\" rel=\"Ext.Base-property-self\" class=\"docClass\">self</a>,\n<code>this.statics()</code>是独立的作用域，无论<code>this</code>是否运行，总是返回其中的调用类。</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Cat', {\n    statics: {\n        totalCreated: 0,\n        speciesName: 'Cat' // My.Cat.speciesName = 'Cat'\n    },\n\n    constructor: function() {\n        var statics = this.statics();\n\n        alert(statics.speciesName);     // 总是等于'Cat'，无论'this'是什么，\n                                        // 相当于：My.Cat.speciesName\n\n        alert(this.self.speciesName);   // 依赖 'this'\n\n        statics.totalCreated++;\n    },\n\n    clone: function() {\n        var cloned = new this.self;                      // 依赖 'this'\n\n        cloned.groupName = this.statics().speciesName;   // 相当于: My.Cat.speciesName\n\n        return cloned;\n    }\n});\n\n\n<a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.SnowLeopard', {\n    extend: 'My.Cat',\n\n    statics: {\n        speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'\n    },\n\n    constructor: function() {\n        this.callParent();\n    }\n});\n\nvar cat = new My.Cat();                 // alerts 'Cat', 然后提示 'Cat'\n\nvar snowLeopard = new My.SnowLeopard(); // alerts 'Cat', 然后提示 'Snow Leopard'\n\nvar clone = snowLeopard.clone();\nalert(<a href=\"#!/api/Ext-method-getClassName\" rel=\"Ext-method-getClassName\" class=\"docClass\">Ext.getClassName</a>(clone));         // alerts 'My.SnowLeopard'\nalert(clone.groupName);                 // alerts 'Cat'\n\nalert(My.Cat.totalCreated);             // alerts 3\n</code></pre>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Ext.Class\" rel=\"Ext.Class\" class=\"docClass\">Ext.Class</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-triggerExtended' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-method-triggerExtended' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-method-triggerExtended' class='name expandable'>triggerExtended</a>( <span class='pre'></span> )<strong class='private signature'>private</strong></div><div class='description'><div class='short'>配置扩展 ...</div><div class='long'><p>配置扩展</p>\n</div></div></div></div><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Static Methods</h3><div id='static-method-addMembers' class='member first-child inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-addMembers' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-addMembers' class='name expandable'>addMembers</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> members</span> )<strong class='static signature'>static</strong></div><div class='description'><div class='short'>方法/属性添加到这个类的原型。 ...</div><div class='long'><p>方法/属性添加到这个类的原型。</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.awesome.Cat', {\n    constructor: function() {\n        ...\n    }\n});\n\n My.awesome.Cat.implement({\n     meow: function() {\n        alert('Meowww...');\n     }\n });\n\n var kitty = new My.awesome.Cat;\n kitty.meow();\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>members</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>成员</p>\n</div></li></ul></div></div></div><div id='static-method-addStatics' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-addStatics' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-addStatics' class='name expandable'>addStatics</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> members</span> ) : <a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a><strong class='static signature'>static</strong></div><div class='description'><div class='short'>添加/重写这个类的静态属性。 ...</div><div class='long'><p>添加/重写这个类的静态属性。</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.cool.Class', {\n    ...\n});\n\nMy.cool.Class.addStatics({\n    someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'\n    method1: function() { ... },    // My.cool.Class.method1 = function() { ... };\n    method2: function() { ... }     // My.cool.Class.method2 = function() { ... };\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>members</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>成员</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a></span><div class='sub-desc'><p>this</p>\n</div></li></ul></div></div></div><div id='static-method-borrow' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-borrow' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-borrow' class='name expandable'>borrow</a>( <span class='pre'><a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a> fromClass, <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a>/<a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a> members</span> ) : <a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a><strong class='private signature'>private</strong><strong class='static signature'>static</strong></div><div class='description'><div class='short'>这个类的原型借用另一个类的成员\n\nExt.define('Bank', {\n    money: '$$$',\n    printMoney: function() {\n        alert('$$$$$$$');\n    }\n...</div><div class='long'><p>这个类的原型借用另一个类的成员</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('Bank', {\n    money: '$$$',\n    printMoney: function() {\n        alert('$$$$$$$');\n    }\n});\n\n<a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('Thief', {\n    ...\n});\n\nThief.borrow(Bank, ['money', 'printMoney']);\n\nvar steve = new Thief();\n\nalert(steve.money); // alerts '$$$'\nsteve.printMoney(); // alerts '$$$$$$$'\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fromClass</span> : <a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a><div class='sub-desc'><p>借用成员的类</p>\n</div></li><li><span class='pre'>members</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a>/<a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a><div class='sub-desc'><p>借用成员的名称</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a></span><div class='sub-desc'><p>this 借用成员</p>\n</div></li></ul></div></div></div><div id='static-method-create' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-create' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-create' class='name expandable'>create</a>( <span class='pre'></span> ) : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><strong class='static signature'>static</strong></div><div class='description'><div class='short'>创建这个类的新实例。 ...</div><div class='long'><p>创建这个类的新实例。</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.cool.Class', {\n    ...\n});\n\nMy.cool.Class.create({\n    someConfig: true\n});\n</code></pre>\n\n<p>所有参数传递至类的构造。</p>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a></span><div class='sub-desc'><p>创建的实例。</p>\n</div></li></ul></div></div></div><div id='static-method-createAlias' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-createAlias' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-createAlias' class='name expandable'>createAlias</a>( <span class='pre'><a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a>/<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> , <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a>/<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> origin</span> )<strong class='static signature'>static</strong></div><div class='description'><div class='short'>创建现有的原型方法的别名。例如：\n\nExt.define('My.cool.Class', {\n    method1: function() { ... ...</div><div class='long'><p>创建现有的原型方法的别名。例如：</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.cool.Class', {\n    method1: function() { ... },\n    method2: function() { ... }\n});\n\nvar test = new My.cool.Class();\n\nMy.cool.Class.createAlias({\n    method3: 'method1',\n    method4: 'method2'\n});\n\ntest.method3(); // test.method1()\n\nMy.cool.Class.createAlias('method5', 'method3');\n\ntest.method5(); // test.method3() -&gt; test.method1()\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'></span> : <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a>/<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>别名新方法的名称，或对象设置多个别名。\n参见<a href=\"#!/api/Ext.Function-method-flexSetter\" rel=\"Ext.Function-method-flexSetter\" class=\"docClass\">flexSetter</a></p>\n</div></li><li><span class='pre'>origin</span> : <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a>/<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>原来的方法名</p>\n</div></li></ul></div></div></div><div id='static-method-getName' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-getName' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-getName' class='name expandable'>getName</a>( <span class='pre'></span> ) : <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a><strong class='static signature'>static</strong></div><div class='description'><div class='short'>以字符串格式，获取当前类的名称。 ...</div><div class='long'><p>以字符串格式，获取当前类的名称。</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.cool.Class', {\n    constructor: function() {\n        alert(this.self.getName()); // alerts 'My.cool.Class'\n    }\n});\n\nMy.cool.Class.getName(); // 'My.cool.Class'\n</code></pre>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a></span><div class='sub-desc'><p>className 类名</p>\n</div></li></ul></div></div></div><div id='static-method-override' class='member  inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><a href='#!/api/Ext.Base' rel='Ext.Base' class='defined-in docClass'>Ext.Base</a><br/><a href='source/Base2.html#Ext-Base-static-method-override' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Base-static-method-override' class='name expandable'>override</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> members</span> ) : <a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a><strong class='deprecated signature'>deprecated</strong><strong class='static signature'>static</strong></div><div class='description'><div class='short'>重写这个类的成员。通过callParent重写的方法可以调用。 ...</div><div class='long'><p>重写这个类的成员。通过<a href=\"#!/api/Ext.Base-method-callParent\" rel=\"Ext.Base-method-callParent\" class=\"docClass\">callParent</a>重写的方法可以调用。</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.Cat', {\n    constructor: function() {\n        alert(\"I'm a cat!\");\n    }\n});\n\nMy.Cat.override({\n    constructor: function() {\n        alert(\"I'm going to be a cat!\");\n\n        this.callParent(arguments);\n\n        alert(\"Meeeeoooowwww\");\n    }\n});\n\nvar kitty = new My.Cat(); // alerts \"I'm going to be a cat!我要成为一只猫！\"\n                          // alerts \"I'm a cat!我是一只猫！\"\n                          // alerts \"Meeeeoooowwww\"\n</code></pre>\n\n<p>在4.1版本, 直接利用这种方法已经过时了。 使用 <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>\n代替:</p>\n\n<pre><code><a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a>('My.CatOverride', {\n    override: 'My.Cat',\n    constructor: function() {\n        alert(\"I'm going to be a cat!\");\n\n        this.callParent(arguments);\n\n        alert(\"Meeeeoooowwww\");\n    }\n});\n</code></pre>\n\n<p>以上完成了相同的结果，但可以由<a href=\"#!/api/Ext.Loader\" rel=\"Ext.Loader\" class=\"docClass\">Ext.Loader</a>重写，\n其目标类和生成过程中，可以决定是否需要根据目标类所需的状态覆盖管理(My.Cat)。</p>\n        <div class='signature-box deprecated'>\n        <p>This method has been <strong>deprecated</strong> since 4.1.0</p>\n        <p>使用 <a href=\"#!/api/Ext-method-define\" rel=\"Ext-method-define\" class=\"docClass\">Ext.define</a> 代替</p>\n\n        </div>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>members</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>添加到这个类的属性。\n这应当被指定为一个对象包含一个或多个属性的文字。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Ext.Base\" rel=\"Ext.Base\" class=\"docClass\">Ext.Base</a></span><div class='sub-desc'><p>this class 当前类</p>\n</div></li></ul></div></div></div></div></div></div></div>"});