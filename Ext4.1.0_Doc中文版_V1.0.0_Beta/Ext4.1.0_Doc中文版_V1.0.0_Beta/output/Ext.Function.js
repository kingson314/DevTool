Ext.data.JsonP.Ext_Function({"tagname":"class","name":"Ext.Function","extends":null,"mixins":[],"alternateClassNames":["Ext.util.Functions"],"aliases":{},"singleton":true,"requires":[],"uses":[],"code_type":"assignment","inheritable":false,"inheritdoc":null,"meta":{"docauthor":["译者: 曹成博<caochengbo12@qq.com>"]},"id":"class-Ext.Function","members":{"cfg":[],"property":[],"method":[{"name":"alias","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-alias"},{"name":"bind","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-bind"},{"name":"clone","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-clone"},{"name":"createBuffered","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-createBuffered"},{"name":"createDelayed","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-createDelayed"},{"name":"createInterceptor","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-createInterceptor"},{"name":"createSequence","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-createSequence"},{"name":"createThrottled","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-createThrottled"},{"name":"defer","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-defer"},{"name":"flexSetter","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-flexSetter"},{"name":"interceptAfter","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-interceptAfter"},{"name":"interceptBefore","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-interceptBefore"},{"name":"pass","tagname":"method","owner":"Ext.Function","meta":{},"id":"method-pass"}],"event":[],"css_var":[],"css_mixin":[]},"statics":{"cfg":[],"property":[],"method":[],"event":[],"css_var":[],"css_mixin":[]},"files":[{"filename":"Function.js","href":"Function2.html#Ext-Function"}],"html_meta":{"docauthor":null},"component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"parentMixins":[],"html":"<div><pre class=\"hierarchy\"><h4>Alternate names</h4><div class='alternate-class-name'>Ext.util.Functions</div><h4>Files</h4><div class='dependency'><a href='source/Function2.html#Ext-Function' target='_blank'>Function.js</a></div></pre><div class='doc-contents'><p>处理回调函数的常用静态方法的集合。</p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-alias' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-alias' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-alias' class='name expandable'>alias</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a>/<a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> object, <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a> methodName</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>为object提供的方法属性名称为methodName的方法创建一个别名。 ...</div><div class='long'><p>为<code>object</code>提供的方法属性名称为<code>methodName</code>的方法创建一个别名。\n注意,执行的作用域仍将被绑定到所提供的“对象”本身。</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>object</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a>/<a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li><li><span class='pre'>methodName</span> : <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a><div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>aliasFn</p>\n</div></li></ul></div></div></div><div id='method-bind' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-bind' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-bind' class='name expandable'>bind</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope, <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a> args, <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a>/<a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> appendArgs</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>根据指定函数 fn 创建一个代理函数，更改 this 作用域为传入的作用域，\n可以选择重写调用的参数。(默认为该函数的参数列表)\n\nExt.bind是Ext.Function.bind的别名 ...</div><div class='long'><p>根据指定函数 <code>fn</code> 创建一个代理函数，更改 <code>this</code> 作用域为传入的作用域，\n可以选择重写调用的参数。(默认为该函数的参数列表)</p>\n\n<p><a href=\"#!/api/Ext-method-bind\" rel=\"Ext-method-bind\" class=\"docClass\">Ext.bind</a>是<a href=\"#!/api/Ext.Function-method-bind\" rel=\"Ext.Function-method-bind\" class=\"docClass\">Ext.Function.bind</a>的别名</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>需要被代理的原始函数。</p>\n\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 该函数执行的作用域(<code>this</code>引用)。\n<strong>如果省略，默认指向默认的全局环境对象(通常是window)。</strong></p>\n\n</div></li><li><span class='pre'>args</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a><div class='sub-desc'><p>(可选) 覆盖原函数的参数列表（默认为该函数的参数列表）。</p>\n\n</div></li><li><span class='pre'>appendArgs</span> : <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a>/<a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>(可选) 如果该参数为true，将参数加载到该函数的后面，\n如果该参数为数字类型，则将参数将插入到所指定的位置。</p>\n\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>新产生的函数</p>\n\n</div></li></ul></div></div></div><div id='method-clone' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-clone' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-clone' class='name expandable'>clone</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> method</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>为当前提供的方法创建一个\"克隆\"。 ...</div><div class='long'><p>为当前提供的方法创建一个\"克隆\"。\n返回的方法将调用传递所有的参数和\"this\"指针沿给定的方法，并返回其结果。</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>method</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>cloneFn</p>\n</div></li></ul></div></div></div><div id='method-createBuffered' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-createBuffered' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-createBuffered' class='name expandable'>createBuffered</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> buffer, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope, <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a> args</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>创建一个缓冲函数，可选绑定范围，在调用时，\n根据配置的毫秒数缓冲执行传递的函数。 ...</div><div class='long'><p>创建一个缓冲函数，可选绑定范围，在调用时，\n根据配置的毫秒数缓冲执行传递的函数。\n如果在此期间该函数被重复调用，则第一次调用将被取消，\n重新开始计算缓冲时间。</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>需要被缓冲的原始函数。</p>\n</div></li><li><span class='pre'>buffer</span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>缓冲函数调用执行的时间，单位是毫秒。</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 该对象将作为代理函数执行的作用域(<code>this</code>引用)。\n如果省略，默认为调用者指定的作用域。</p>\n</div></li><li><span class='pre'>args</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a><div class='sub-desc'><p>(可选) 覆盖该次调用的参数列表。（默认为该函数的参数列表）。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>一个函数，在指定的时间缓冲之后调用传递的函数。</p>\n</div></li></ul></div></div></div><div id='method-createDelayed' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-createDelayed' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-createDelayed' class='name expandable'>createDelayed</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> delay, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope, <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a> args, <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a>/<a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> appendArgs</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>创建一个委派对象（就是回调），调用时，在一个特定的延迟后执行。 ...</div><div class='long'><p>创建一个委派对象（就是回调），调用时，在一个特定的延迟后执行。</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>当返回的函数调用时，该函数将在一个延迟后被调用。\n可选地,可以指定一个更换(或更多)的参数列表。</p>\n</div></li><li><span class='pre'>delay</span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>每当调用时推迟执行的毫秒数。</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 函数在执行时所使用的作用域(<code>this</code>引用)。</p>\n</div></li><li><span class='pre'>args</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a><div class='sub-desc'><p>(可选) 覆盖原函数的参数列表（默认为该函数的参数列表）。</p>\n</div></li><li><span class='pre'>appendArgs</span> : <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a>/<a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>(可选) 如果该参数为true，将参数加载到该函数的后面，\n如果该参数为数字类型，则将参数将插入到所指定的位置。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>一个函数，调用时，在指定的延迟之后执行原函数。</p>\n</div></li></ul></div></div></div><div id='method-createInterceptor' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-createInterceptor' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-createInterceptor' class='name expandable'>createInterceptor</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> origFn, <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> newFn, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> returnValue</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>创建一个拦截函数。传递的函数在原函数之前被调用。如果拦截函数返回false，\n则原函数不会被调用。在返回函数中，将返回原函数的返回值。 ...</div><div class='long'><p>创建一个拦截函数。传递的函数在原函数之前被调用。如果拦截函数返回false，\n则原函数不会被调用。在返回函数中，将返回原函数的返回值。\n拦截函数被调用时会被传入原函数的参数。例如:</p>\n\n<pre><code>var sayHi = function(name){\n    alert('Hi, ' + name);\n}\n\nsayHi('Fred'); // 提示 \"Hi, Fred\"\n\n// 不修改原函数的前提下\n// 创建新的验证函数:\nvar sayHiToFriend = <a href=\"#!/api/Ext.Function-method-createInterceptor\" rel=\"Ext.Function-method-createInterceptor\" class=\"docClass\">Ext.Function.createInterceptor</a>(sayHi, function(name){\n    return name == 'Brian';\n});\n\nsayHiToFriend('Fred');  // 没提示\nsayHiToFriend('Brian'); // 提示 \"Hi, Brian\"\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>origFn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>原始函数</p>\n</div></li><li><span class='pre'>newFn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>新的拦截函数</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 传递的函数执行的作用域(<code>this</code>引用)。\n<strong>如果省略，默认指向被调用的原函数作用域或window。</strong></p>\n</div></li><li><span class='pre'>returnValue</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选)返回的值，如果传递的函数返回false（默认为 null）。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>新产生的函数。</p>\n</div></li></ul></div></div></div><div id='method-createSequence' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-createSequence' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-createSequence' class='name expandable'>createSequence</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> originalFn, <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> newFn, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>创建一个组合函数，调用次序为：原函数 + 参数中的函数。 ...</div><div class='long'><p>创建一个组合函数，调用次序为：原函数 + 参数中的函数。\n该函数返回了原函数执行的结果（也就是返回了原函数的返回值）。\n在参数中传递的函数，它的参数也是原函数的参数。 用法示例:</p>\n\n<pre><code>var sayHi = function(name){\n    alert('Hi, ' + name);\n}\n\nsayHi('Fred'); // 提示 \"Hi, Fred\"\n\nvar sayGoodbye = <a href=\"#!/api/Ext.Function-method-createSequence\" rel=\"Ext.Function-method-createSequence\" class=\"docClass\">Ext.Function.createSequence</a>(sayHi, function(name){\n    alert('Bye, ' + name);\n});\n\nsayGoodbye('Fred'); // 显示两个提示\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>originalFn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>原始函数。</p>\n</div></li><li><span class='pre'>newFn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>新的组合函数</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 传递的函数执行的作用域(<code>this</code>引用)。\n如果省略，默认指向默认的全局环境对象(通常是window)。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>新产生的函数</p>\n</div></li></ul></div></div></div><div id='method-createThrottled' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-createThrottled' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-createThrottled' class='name expandable'>createThrottled</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> interval, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>创建一个指定函数的减速代理，\n当减速函数被反复快速回调时，\n只有在上次调用完成的指定间间隔之后才会被调用。 ...</div><div class='long'><p>创建一个指定函数的减速代理，\n当减速函数被反复快速回调时，\n只有在上次调用完成的指定间间隔之后才会被调用。</p>\n\n<p>对于包装可被反复调用的函数，如鼠标移动事件的情况下的处理程序时，\n处理是极其昂贵的，这是非常有用的。</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>要在一个固定的时间间隔执行的函数。</p>\n</div></li><li><span class='pre'>interval</span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>减速函数执行的时间间隔<strong>毫秒为单位</strong>。</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 传递的函数执行的作用域(<code>this</code>引用)。\n如果省略，默认为调用者指定的作用域。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>一个函数，在指定的时间间隔调用传递函数。</p>\n</div></li></ul></div></div></div><div id='method-defer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-defer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-defer' class='name expandable'>defer</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> millis, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope, <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a> args, <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a>/<a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a> appendArgs</span> ) : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a></div><div class='description'><div class='short'>延迟调用该函数。你可以加入一个作用域的参数，例如:\n\nvar sayHi = function(name){\n    alert('Hi, ' + name);\n}\n\n// 即刻执行的:\nsayHi('Fred');\n\n// 两秒过后...</div><div class='long'><p>延迟调用该函数。你可以加入一个作用域的参数，例如:</p>\n\n<pre><code>var sayHi = function(name){\n    alert('Hi, ' + name);\n}\n\n// 即刻执行的:\nsayHi('Fred');\n\n// 两秒过后执行的:\n<a href=\"#!/api/Ext.Function-method-defer\" rel=\"Ext.Function-method-defer\" class=\"docClass\">Ext.Function.defer</a>(sayHi, 2000, this, ['Fred']);\n\n// 有时候加上一个匿名\n// 函数也是很方便的:\n<a href=\"#!/api/Ext.Function-method-defer\" rel=\"Ext.Function-method-defer\" class=\"docClass\">Ext.Function.defer</a>(function(){\n    alert('Anonymous');\n}, 100);\n</code></pre>\n\n<p><a href=\"#!/api/Ext-method-defer\" rel=\"Ext-method-defer\" class=\"docClass\">Ext.defer</a>是<a href=\"#!/api/Ext.Function-method-defer\" rel=\"Ext.Function-method-defer\" class=\"docClass\">Ext.Function.defer</a>的别名</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>要延迟执行的函数。</p>\n\n</div></li><li><span class='pre'>millis</span> : <a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>延迟时间，以毫秒为单位\n(如果小于或等于 0 函数则立即执行)</p>\n\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 该函数执行的作用域(<code>this</code>引用)。\n<strong>如果省略，默认指向window。</strong></p>\n\n</div></li><li><span class='pre'>args</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a><div class='sub-desc'><p>(可选) 覆盖原函数的参数列表 (默认为该函数的参数列表)</p>\n\n</div></li><li><span class='pre'>appendArgs</span> : <a href=\"#!/api/Boolean\" rel=\"Boolean\" class=\"docClass\">Boolean</a>/<a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a><div class='sub-desc'><p>(可选) 如果该参数为true，将参数加载到该函数的后面，\n如果该参数为数字类型，则将参数将插入到所指定的位置。</p>\n\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Number\" rel=\"Number\" class=\"docClass\">Number</a></span><div class='sub-desc'><p>可被clearTimeout所使用的timeout id</p>\n\n</div></li></ul></div></div></div><div id='method-flexSetter' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-flexSetter' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-flexSetter' class='name expandable'>flexSetter</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> setter</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>整个框架的一个很常用的方法。 ...</div><div class='long'><p>整个框架的一个很常用的方法。\n它作为另一种方法的包装，最初接受2个参数 <code>name</code> 和 <code>value</code>。\n被包装的函数可以\"灵活\"的对值进行设置为其他值:</p>\n\n<ul>\n<li><code>name</code> 和 <code>value</code> 作为2个参数</li>\n<li>一个单一的对象参数与多个键-值对</li>\n</ul>\n\n\n<p>示例:</p>\n\n<pre><code>var setValue = <a href=\"#!/api/Ext.Function-method-flexSetter\" rel=\"Ext.Function-method-flexSetter\" class=\"docClass\">Ext.Function.flexSetter</a>(function(name, value) {\n    this[name] = value;\n});\n\n// 之后\n// 设置单个名称-值\nsetValue('name1', 'value1');\n\n// 设置多个名称-值对\nsetValue({\n    name1: 'value1',\n    name2: 'value2',\n    name3: 'value3'\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>setter</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>flexSetter</p>\n</div></li></ul></div></div></div><div id='method-interceptAfter' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-interceptAfter' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-interceptAfter' class='name expandable'>interceptAfter</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> object, <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a> methodName, <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, [<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope]</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>将行为添加到现有的方法是在该函数的原始行为之后执行。 ...</div><div class='long'><p>将行为添加到现有的方法是在该函数的原始行为之后执行。\n例如:</p>\n\n<pre><code>var soup = {\n    contents: [],\n    add: function(ingredient) {\n        this.contents.push(ingredient);\n    }\n};\n<a href=\"#!/api/Ext.Function-method-interceptAfter\" rel=\"Ext.Function-method-interceptAfter\" class=\"docClass\">Ext.Function.interceptAfter</a>(soup, \"add\", function(ingredient){\n    // 总是添加少量额外的盐\n    this.contents.push(\"salt\");\n});\nsoup.add(\"water\");\nsoup.add(\"onions\");\nsoup.contents; // 将包含：水、盐、葱、盐\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>object</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>目标对象</p>\n</div></li><li><span class='pre'>methodName</span> : <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a><div class='sub-desc'><p>要重写的方法名称</p>\n</div></li><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>新的行为函数。\n它将与原始方法相同的参数调用。\n此函数的返回值将成为新方法的返回值。</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> (optional)<div class='sub-desc'><p>要执行拦截器函数的作用域。默认为当前对象。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>刚创建的新函数。</p>\n</div></li></ul></div></div></div><div id='method-interceptBefore' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-interceptBefore' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-interceptBefore' class='name expandable'>interceptBefore</a>( <span class='pre'><a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> object, <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a> methodName, <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, [<a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope]</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>将行为添加到现有的方法是在该函数的原始行为之前执行。 ...</div><div class='long'><p>将行为添加到现有的方法是在该函数的原始行为之前执行。\n例如:</p>\n\n<pre><code>var soup = {\n    contents: [],\n    add: function(ingredient) {\n        this.contents.push(ingredient);\n    }\n};\n<a href=\"#!/api/Ext.Function-method-interceptBefore\" rel=\"Ext.Function-method-interceptBefore\" class=\"docClass\">Ext.Function.interceptBefore</a>(soup, \"add\", function(ingredient){\n    if (!this.contents.length &amp;&amp; ingredient !== \"water\") {\n        // 总是首先添加水\n        this.contents.push(\"water\");\n    }\n});\nsoup.add(\"onions\");\nsoup.add(\"salt\");\nsoup.contents; // 将包含：水、葱、盐\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>object</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>目标对象</p>\n</div></li><li><span class='pre'>methodName</span> : <a href=\"#!/api/String\" rel=\"String\" class=\"docClass\">String</a><div class='sub-desc'><p>要重写的方法名称</p>\n</div></li><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>新的行为函数。\n它将与原始方法相同的参数调用。\n此函数的返回值将成为新方法的返回值。</p>\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> (optional)<div class='sub-desc'><p>要执行拦截器函数的作用域。默认为当前对象。</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>刚创建的新函数。</p>\n</div></li></ul></div></div></div><div id='method-pass' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Ext.Function'>Ext.Function</span><br/><a href='source/Function2.html#Ext-Function-method-pass' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Ext.Function-method-pass' class='name expandable'>pass</a>( <span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> fn, <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a> args, <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a> scope</span> ) : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></div><div class='description'><div class='short'>从提供'fn'创建一个新的函数，其中的参数预先设置到 'args'。 ...</div><div class='long'><p>从提供'fn'创建一个新的函数，其中的参数预先设置到 'args'。\n新的参数传递到新创建的回调函数中，调用时追加到预先设定的参数之后。\n创建的回调时，这是特别有用的。</p>\n\n<p>示例:</p>\n\n<pre><code>var originalFunction = function(){\n    alert(<a href=\"#!/api/Ext.Array-method-from\" rel=\"Ext.Array-method-from\" class=\"docClass\">Ext.Array.from</a>(arguments).join(' '));\n};\n\nvar callback = <a href=\"#!/api/Ext.Function-method-pass\" rel=\"Ext.Function-method-pass\" class=\"docClass\">Ext.Function.pass</a>(originalFunction, ['Hello', 'World']);\n\ncallback(); // 执行结果为 'Hello World'\ncallback('by Me'); // 执行结果为 'Hello World by Me'\n</code></pre>\n\n<p><a href=\"#!/api/Ext-method-pass\" rel=\"Ext-method-pass\" class=\"docClass\">Ext.pass</a>是<a href=\"#!/api/Ext.Function-method-pass\" rel=\"Ext.Function-method-pass\" class=\"docClass\">Ext.Function.pass</a>的别名</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>fn</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>原始函数</p>\n\n</div></li><li><span class='pre'>args</span> : <a href=\"#!/api/Array\" rel=\"Array\" class=\"docClass\">Array</a><div class='sub-desc'><p>要传递给新的回调函数的参数</p>\n\n</div></li><li><span class='pre'>scope</span> : <a href=\"#!/api/Object\" rel=\"Object\" class=\"docClass\">Object</a><div class='sub-desc'><p>(可选) 该函数执行的作用域(<code>this</code>引用)。</p>\n\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a></span><div class='sub-desc'><p>新的回调函数</p>\n\n</div></li></ul></div></div></div></div></div></div></div>"});